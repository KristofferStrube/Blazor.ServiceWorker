// This is the minified version of the service worker script defined in the library using https://codebeautify.org/minify-js
const params = new Proxy(new URLSearchParams(self.location.search), { get: (e, t) => e.get(t) }); let id = params.id, root = self.location.origin + params.root + "/", proxyDict = {}; proxyDict[id] = self; let resolvers = {}; async function handleFetch(e) { var t = generateGUID(), r = new Promise(((e, r) => { resolvers[t] = e })); return invokePost("Fetch", t, e), await r } function invokePost(e, t, r) { clients.matchAll({ type: "window", includeUncontrolled: !0 }).then((([o]) => { if (null != o) { proxyDict[t] = r; var s = { type: e, id: id, eventId: t }; o.postMessage(s) } })) } function resolvePost(e, t, r) { clients.matchAll({ type: "window", includeUncontrolled: !0 }).then((([o]) => { if (null != o) { var s = { type: `Resolve${e}`, id: t, object: r }; o.postMessage(s) } })) } function generateGUID() { var e = (new Date).getTime(), t = "undefined" != typeof performance && performance.now && 1e3 * performance.now() || 0; return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function (r) { var o = 16 * Math.random(); return e > 0 ? (o = (e + o) % 16 | 0, e = Math.floor(e / 16)) : (o = (t + o) % 16 | 0, t = Math.floor(t / 16)), ("x" === r ? o : 3 & o | 8).toString(16) })) } self.oninstall = e => { invokePost("Install", generateGUID(), e) }, self.onactivate = e => { invokePost("Activate", generateGUID(), e) }, self.onfetch = e => { [root, root + "_vs/browserLink", root + "css/bootstrap/bootstrap.min.css", root + "css/app.css", root + "KristofferStrube.Blazor.ServiceWorker.WasmExample.styles.css", root + "css/open-iconic/font/css/open-iconic-bootstrap.min.css", root + "favicon.png", root + "_content/KristofferStrube.Blazor.ServiceWorker/KristofferStrube.Blazor.ServiceWorker.js"].includes(e.request.url) || e.request.url.startsWith("http://") || e.request.url.startsWith("wss://") || e.request.url.startsWith("ws://") || e.request.url.startsWith(root + "?") || e.request.url.includes("/_framework/") || e.respondWith(handleFetch(e)) }, self.onpush = e => { invokePost("Push", generateGUID(), e) }, self.addEventListener("message", (e => { var t = e.data; if ("GetProxyAttributeAsProxy" == t.type) { var r = proxyDict[t.id][t.attribute], o = generateGUID(); proxyDict[o] = r, resolvePost(t.type, t.id, o) } else if ("GetProxyAttribute" == t.type) { r = proxyDict[t.id][t.attribute]; resolvePost(t.type, t.id, r) } else if (t.type.startsWith("Call")) { for (let e = 0; e < t.args.length; e++)null != t.args[e] && 36 == t.args[e].length && "-" == t.args[e].charAt(8) && (t.args[e] = proxyDict[t.args[e]]); if ("CallProxyMethodAsProxy" == t.type) { r = proxyDict[t.id][t.method].apply(proxyDict[t.id], t.args), o = generateGUID(); proxyDict[o] = r, resolvePost(t.type, t.id, o) } else if ("CallProxyAsyncMethodAsProxy" == t.type) proxyDict[t.id][t.method].apply(proxyDict[t.id], t.args).then((e => { var r = generateGUID(); null == e ? r = void 0 : proxyDict[r] = e, resolvePost(t.type, t.id, r) })); else if ("CallProxyMethod" == t.type) { r = proxyDict[t.id][t.method].apply(proxyDict[t.id], t.args); resolvePost(t.type, t.id, r) } else "CallResolveRespondWith" == t.type && resolvers[t.id].apply(this, t.args) } })), skipWaiting();

